---
date: "2020-10-14"
title: "Announcing Tokio 0.3 and the path to 1.0"
description: "October 14, 2020"
---

The Tokio team is excited to announce the release of Tokio 0.3, which is our beta release towards Tokio 1.0. This release serves two purposes: it allows us to correct issues we have found in the API that Tokio 0.2 exposes and it gives the broader Tokio community the opportunity to try out the new APIs before we commit to them long-term in Tokio 1.0.

With Tokio 0.3, we focused on fixing issues and papercuts found in the Tokio 0.2 API. Since most of these issues are small, we expect that upgrading from Tokio 0.2 to 0.3 will be easy. We also expect that this migration will be significantly easier than the 0.1 to 0.2 migration.

# Plan for 1.0

The Tokio team plans to release Tokio 1.0 at the end of Q4 2020. We intend to use Tokio 0.3 for several months, resolve any issues that emerge, and release Tokio 1.0. To do this, we ask that *you*, the Tokio community, try out Tokio 0.3 and give us feedback through [GitHub Issues](https://github.com/tokio-rs/tokio/issues) or our [Discord channel](https://discord.gg/tokio). Once we release Tokio 1.0, we will commit to the following stability guarantees:


1. A minimum of 5 years of maintenance.
2. A minimum of 3 years before a hypothetical 2.0 release.

Sometime after the release of Tokio 1.0, we will introduce a minimum supported Rust version (MSRV) policy where we plan to support the last six months of stable Rust releases. We are delaying the introduction of this MSRV policy to accommodate the inclusion of the `Stream` trait in the standard library.

# What’s new?

The main changes in Tokio 0.3 are:

1. Changes to IO traits.
2. New runtime builder.
3. Many methods changed from `&mut self` to `&self`.
4. Removal of non-1.0 crates from the public API

You can find the full list on the [changelog](TODO LINK).

## Changes to IO traits

This release of Tokio contains changes to the `AsyncRead` and `AsyncWrite` traits that allow them to properly handle uninitialized memory. This change is motivated by an RFC to Rust: [Reading into uninitialized buffers](https://github.com/rust-lang/rfcs/pull/2930). Note that this change *only* affects users who implement the `AsyncRead` or `AsyncWrite` traits or manually calling the `poll_*` methods. If the traits are consumed through the `AsyncReadExt` or `AsyncWriteExt` traits, users will not have to change anything.

A simplified version of the new `AsyncRead` trait looks like this:

```rust
pub trait AsyncRead {
    fn poll_read(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        buf: &mut ReadBuf<'_>
    ) -> Poll<Result<()>>;
}

pub struct ReadBuf<'a> {
    buf: &'a mut [MaybeUninit<u8>],
    filled: usize,
    initialized: usize,
}

impl<'a> ReadBuf<'a> {
    // functions here, see RFC
}
```

The traditional `&mut [u8]` argument to the `poll_read` method has some unintended sharp edges: an implementer, not the end consumer, of the `AsyncRead` trait can *read* the data stored in the `&mut [u8]` slice. This means that if a programmer creates a mutable slice of bytes (a `&mut [u8]`) that references uninitialized memory (e.g., the excess capacity in a vector), *reading* the `&mut [u8]` data would cause undefined behavior. We mitigate this issue by providing a `ReadBuf` struct that tracks what memory is properly initialized and removing the need to constantly initialize (e.g., zero-out) memory.

Additionally, the `poll_read_buf` and `poll_write_buf` methods are removed from both traits.

## Feature flag simplification

We have reduced the amount of feature flags needed to use the core features of Tokio. This includes collpasing `tcp`, `udp`,  and `uds` into a single `net` feature flag. We have also removed `rt-util` and merged both what was under `rt-util` and `rt-core` into a new `rt` feature flag. This `rt` feature flag now encompasses everything to execute futures except for the multi threaded runtime which now lives under a `rt-multi-thread` feature flag (previously was called `rt-threaded`).

- `tcp`, `udp` and `uds` -> `net`
- `rt-util` and `rt-core` -> `rt`
- `rt-threaded` -> `rt-multi-threaded`

## Runtime and Builder refactor

The Tokio team has removed  `threaded_scheduler` and `basic_scheduler` from the public API. Instead, the runtime `Builder` type introduces two constructors: one constructor for a multi threaded scheduler and one for a current thread scheduler. These constructors provide a misuse-resistant form of building a runtime that *does not* require fiddling with feature flags and build methods. Tokio will no longer choose the runtime variant based on feature flags when using `Runtime::new` but instead will default to the multi threaded runtime and is only available under the `rt` feature flag. In addition, we’ve renamed the `core_threads` builder method to the more accurate `worker_threads`. 

We have also refactored the runtime module. Tokio 0.2 exposed two types to interact with the Tokio runtime: `Runtime` and `Handle`. `Runtime` has a `block_on` method that required `&mut self`, whereas `Handle` has a `block_on` method that required `&self`. With Tokio 0.3, we collapsed Runtime and `Handle` into a single `Runtime`. Tokio 0.3’s `Runtime`‘s `block_on` now accepts `&self`, which supports concurrent calls to `block_on`. This also means `Runtime` implements `Send` and `Sync`, and can therefore be stored in an `Arc`.

An example configuring a multi threaded runtime with 6 worker threads:

```rust
use tokio::runtime::Builder;

let rt = Builder::new_multi_thread()
    .worker_threads(6)
    .enable_all()
    .build()
    .unwrap();

rt.block_on(async {
    println!("Hello world!");
});
```

## Methods changed to `&self`

We have updated our io types to use an intrusive linked-list for storing the wakers. This has allowed us to change many of the methods on types like `TcpStream` and `UdpSocket` to merely take `&self`. This makes it easier to work with our io types accross tasks.

## Removal of non-1.0 crates from the public API

In our push for 1.0 we have removed many non-1.0 dependencies from the public API. This includes `bytes` and `mio`. This will allow us to push for a simpler and more stable 1.0 while we continue to innovate in our low level crates.

## Mio 0.7

We have finally also upgraded `mio` to 0.7 which was originally released in an alpha in December of 2019 and did not make the cut for Tokio 0.2. Since, then `mio` 0.7 has had time to mature and is finally making it into this release of Tokio 0.3. This upgrades some key dependencies like `winapi` from 0.2 to 0.3.

# Conclusion

We've had over 50 contributors help us out since the release of Tokio 0.2. We can't thank our community enough for helping us find bugs and fixing them. As we continue to move towards 1.0 feedback will be more critical then ever, so please feel free to open issues or join us on [discord](https://discord.gg/tokio) to help us get there.
